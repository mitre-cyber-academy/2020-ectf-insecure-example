#!/usr/bin/env python3
"""
Description: Protects song by adding metadata or any other security measures
Use: Once per song
"""
import json
import struct
import os
import wave
from argparse import ArgumentParser
import numpy as np

# Used for encryption
import nacl.bindings as b
import nacl.exceptions as exc
import nacl.hash
import nacl.encoding

# calculating the chunk remainder
import math

# TODO: Move encryption processes to separate functions
# TODO: Map arguments to correct variables
# TODO: Move nonces to encrypted chunk, keep first nonce public

class ProtectedSong(object):
    """Example song object for protected song"""

    def __init__(self, path_to_song, metadata):
        """initialize values
        :
            path_to_song (string): file name where the song to be provisioned is stored
            metadata (bytearray): bytes containing metadata information
        """
        self.song = path_to_song
        self.full_song, self.original_song = self.read_song(path_to_song)
        self.metadata = metadata
        self.metadata_size = metadata[:1]

    def save_secured_song_to_wave(self, file_location):
        """Saves secured song to wave file assuming all the same characteristics as original song
        Args:
            file_location (string): location to store the file including name"""
        protected_wav = wave.open(os.path.abspath(file_location), 'wb')
        protected_wav.setnchannels(self.original_song.getnchannels())
        protected_wav.setsampwidth(self.original_song.getsampwidth())
        protected_wav.setframerate(self.original_song.getframerate())
        protected_wav.writeframes(self.metadata)

        for val in self.full_song:
            protected_wav_val = struct.pack('<h', val)
            protected_wav.writeframesraw(protected_wav_val)

        protected_wav.close()

    def read_song(self, path, metadata_frames=0):
        """Reads a wave file
        Args:
            path (string): path to song
            metadata_frames (int): if not 0 disregard this number of frames as metadata
        Returns:
            vals (array): integer array of decoded values
            song (Wave Object): wave object associated with entered song
        """
        song = wave.open(os.path.abspath(path), 'r')
        if metadata_frames:
            song.readframes(metadata_frames)  # skip the metadata frames when assigning vals
        vals = np.frombuffer(song.readframes(song.getnframes()), dtype=np.int16)
        song.close()
        return vals, song

    def encrypt_song(self, keys_loc, outfile):
        # Configuration Variables
        sample_rate = 48000     # 48KHz
        chunk_time = 30         # 30s
        bytes_per_sample = 2    # 2 bytes sampled
        chunk_size = sample_rate * chunk_time * bytes_per_sample
        hash_byte_size = 12     # Take 12 bytes of a 256 bit hash
        wave_header_size = 44   # http://soundfile.sapp.org/doc/WaveFormat/
        aad_size = 4            # Use 4 bytes to store aad size
        metadata_size_allocation = 8

        encoder = nacl.encoding.RawEncoder
        encrypted_file_size = 0 # Track total file size

        # Open song for reading raw data
        song = open(self.song, "rb")

        # Read wav file header
        wave_header = song.read(wave_header_size)

        # The last 4 bytes of a wav file header includes the song size
        song_info_size = int.from_bytes(wave_header[-4:], byteorder='little')

        # Calculate number of chunks to read
        chunk_to_read = math.floor(song_info_size / chunk_size)

        # Calculate remainder
        chunk_remainder = song_info_size % chunk_size

        # Append metadata size onto fileheader
        metadata_size = len(self.metadata).to_bytes(metadata_size_allocation, 'little')
        wave_header_raw = bytearray(wave_header)
        wave_header_raw.extend(metadata_size)
        wave_header_combined = bytes(wave_header_raw)

        encrypted_file_size += len(self.metadata)

        # Open secrets
        keys_file = json.load(open(keys_loc, "r"))
        
        key = bytes.fromhex(keys_file["key"])
        iv = bytes.fromhex(keys_file["iv"])

        print("Starting encrypt song")

        # Calculate header hash for nonce
        header_hash = nacl.hash.sha256(wave_header_combined, encoder=encoder)

        # Take first 12 bytes of header hash
        nonce = header_hash[:hash_byte_size]

        # Open encrypted song file pointer
        encrypted_song = open(outfile, "wb")
        
        # Write the 12 bytes of the header hash
        encrypted_song.write(nonce)

        aad = b"wave_header\0"
        
        # Encrypt Wav Header
        encrypted_header = b.crypto_aead_chacha20poly1305_ietf_encrypt(wave_header_combined, aad, nonce, key)

        encrypted_file_size += len(encrypted_header)

        # Write Encrypted wave header
        encrypted_song.write(encrypted_header)

        metadata_hash = nacl.hash.sha256(self.metadata, encoder=encoder)
        

        nonce = metadata_hash[:hash_byte_size]

        encrypted_song.write(nonce)

        aad = b"meta_data\0"

        encrypted_metadata = b.crypto_aead_chacha20poly1305_ietf_encrypt(self.metadata, aad, nonce, key)

        encrypted_file_size += len(encrypted_metadata)

        # Write encrypted metadata
        encrypted_song.write(encrypted_metadata)

        # Add 1 since range is exclusive
        for i in range(1, chunk_to_read + 1):
            thirty_seconds = song.read(chunk_size)

            chunk_hash = nacl.hash.sha256(thirty_seconds, encoder=encoder)

            nonce = chunk_hash[:hash_byte_size]

            encrypted_song.write(nonce)
            

            aad = int.to_bytes(i, aad_size, 'little')

            encrypted_chunk = b.crypto_aead_chacha20poly1305_ietf_encrypt(thirty_seconds, aad, nonce, key)

            encrypted_file_size += len(encrypted_chunk)

            # Write chunk
            encrypted_song.write(encrypted_chunk)
            
        thirty_seconds = song.read(chunk_remainder)


        chunk_hash = nacl.hash.sha256(thirty_seconds, encoder=encoder)

        nonce = chunk_hash[:hash_byte_size]

        encrypted_song.write(nonce)


        aad = int.to_bytes(chunk_to_read + 1, aad_size, 'little')
        encrypted_chunk = b.crypto_aead_chacha20poly1305_ietf_encrypt(thirty_seconds, aad, nonce, key)

        encrypted_file_size += len(encrypted_chunk)


        # Write remainders
        encrypted_song.write(encrypted_chunk)

        encrypted_song.close()

        song.close()

        print("Encryption Success")

def create_metadata(regions, user, user_secret_location, region_info):
    """Returns a byte string formatted as follows:
    METADATA_LENGTH(1B)/ownerID(1B)/REGION_LEN(1B)/USER_LEN(1B)/REGIONID1(1B)/REGIONID2 (1B)/.../opt. parity
    Args:
        regions (list): list of regions to provision song for
        user (string): user name for owner of the song
        user_secret_location (string): path to user secrets file
        region_info (dict): mapping of regions provided by region_information.json
    Returns:
        metadata (bytes): bytes of encoded metadata
    Example:
        >>create_metadata(['USA', 'Canada'], 'user1', 'user_secrets.json', {'USA': 1, 'Canada':2})
        'x06/x00/x01/x00/x01/x02'
    """
    user_secrets = json.load(open(os.path.abspath(user_secret_location)))

    # note: metadata must be an even length since each sample is 2B long
    # and ARM processors require memory accesses to be aligned to the type size
    metadata = struct.pack(
        '=3B{regions_length}s{regions_len_2}s'.format(regions_length=len(regions), regions_len_2=len(regions) % 2),
        int(user_secrets[user]['id']), len(regions), 0,
        bytes([region_info[str(r)] for r in regions]),
        b'\x00' if len(regions) % 2 else b'')
    return bytes([len(metadata) + 1]) + metadata


def main():
    parser = ArgumentParser(description='main interface to protect songs')
    parser.add_argument('--region-list', nargs='+', help='List of regions song can be played in', required=True)
    parser.add_argument('--region-secrets-path', help='File location for the region secrets file',
                        required=True)
    parser.add_argument('--outfile', help='path to save the protected song', required=True)
    parser.add_argument('--infile', help='path to unprotected song', required=True)
    parser.add_argument('--owner', help='owner of song', required=True)
    parser.add_argument('--user-secrets-path', help='File location for the user secrets file', required=True)
    args = parser.parse_args()

    regions = json.load(open(os.path.abspath(args.region_secrets_path)))
    try:
        metadata = create_metadata(args.region_list, args.owner, args.user_secrets_path, regions)
    except ValueError:
        raise ValueError('Ensure all user IDs are integers and all regions are in the provided region_information.json')
    protected_song = ProtectedSong(args.infile, metadata)
    protected_song.save_secured_song_to_wave(args.outfile)
    protected_song.encrypt_song("keys.json", args.outfile)


if __name__ == '__main__':
    main()
